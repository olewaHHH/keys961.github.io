---
layout: post
title: "Kafka技术内幕-存储层(2)"
author: "keys961"
comments: true
catalog: true
tags:
  - Kakfa
typora-root-url: ./
---

# 0. 概览

本节主要看服务端如何处理读写请求。

# 1. 服务端处理读写请求

消息的读写请求通过`KafkaApis`进入，然后会进入副本管理器`ReplicaManager`，接着找到对应的分区`Partition`和副本`Replica`，然后落入日志`Log`的读写。

日志的读写已经在之前说明了，这里关键的是副本管理器`ReplicaManager`，读写的请求会首先由它进行处理：

```scala
class KafkaApis(...) {
  def handle(request: RequestChannel.Request): Unit = {
    try {
    	// ...
      case ApiKeys.PRODUCE => handleProduceRequest(request) // 生产
      case ApiKeys.FETCH => handleFetchRequest(request) // 消费
    }
  }
}
```

```scala
// 处理生产请求
def handleProduceRequest(request: RequestChannel.Request): Unit = {
  val produceRequest = request.body[ProduceRequest]
  // ...
  def sendResponseCallback(responseStatus: Map[TopicPartition, PartitionResponse]): Unit = {
    // ...
  }
  def processingStatsCallback(processingStats: FetchResponseStats): Unit = {
    // ...
  }
  if (authorizedRequestInfo.isEmpty)
    sendResponseCallback(Map.empty)
  else {
    val internalTopicsAllowed = request.header.clientId == AdminUtils.AdminClientId
    // 通过ReplicaManager生产/追加消息
    replicaManager.appendRecords(
      timeout = produceRequest.timeout.toLong,
      requiredAcks = produceRequest.acks,
      internalTopicsAllowed = internalTopicsAllowed,
      origin = AppendOrigin.Client,
      entriesPerPartition = authorizedRequestInfo,
      responseCallback = sendResponseCallback,
      recordConversionStatsCallback = processingStatsCallback)
    produceRequest.clearPartitionRecords()
  }
}
```

```scala
// 处理消费请求
def handleFetchRequest(request: RequestChannel.Request): Unit = {
  // ...
  val fetchRequest = request.body[FetchRequest]
  // ...
  def errorResponse[T >: MemoryRecords <: BaseRecords](error: Errors): FetchResponse.PartitionData[T] = {
     // ...
  }
  // ...
  def maybeConvertFetchedData(tp: TopicPartition,
                              partitionData: FetchResponse.PartitionData[Records]): {
    // ...
  }
  def processResponseCallback(responsePartitionData: Seq[(TopicPartition, FetchPartitionData)]): Unit = {
     // ...
  }
  // ...
  if (interesting.isEmpty)
    processResponseCallback(Seq.empty)
  else {
    // 由ReplicaManager处理消费请求
    replicaManager.fetchMessages(
      fetchRequest.maxWait.toLong,
      fetchRequest.replicaId,
      fetchMinBytes,
      fetchMaxBytes,
      versionId <= 2,
      interesting,
      replicationQuota(fetchRequest),
      processResponseCallback,
      fetchRequest.isolationLevel,
      clientMetadata)
  }
}
```

## 1.1. 追加和读取本地日志

收到请求后，首先都必须要获取请求所需要的分区对象，然后再获取到分区的主副本：

- 追加：在分区`Partition`中获取主副本，然后写入消息
- 读取：在副本管理器`ReplicationManager`中获取主副本，然后读取消息

它们获取的主副本