---
layout: post
title: "源码阅读-Netty ChannelPipeline(1)"
author: "keys961"
comments: true
catalog: true
tags:
  - Java
typora-root-url: ./
---

# 0. 回顾

之前讲了一个Netty服务端和客户端启动所需要的一些组件，以及相互交互时通信的通道`Channel`。

而`Channel`的创建，不仅仅需要创建`socket`句柄，将Java NIO的`Channel`包装，而且还需要：

- 将其和`EventGroup`集成
- 将其和`ChannelPipeline`集成
- 错误处理
- ...

这里要讲的是`ChannelPipeline`。

# 1. `ChannelPipeline`的大体说明

每个`Channel`内部会维护一个`channelPipeline`（即`ChannelPipeline`），而`channelPipeline`由一系列`channelHandler`（**即`ChannelHandler`，实际上是被`ChannelHandlerContext`包装**）组成一条**双向链表**。

而`channelHandler`用于处理任务逻辑，多个`channelHandler`构成**职责链**，共同完成一项任务。

# 2. Inbound & Outbound

Netty引入Inbound和Outbound概念，将`ChannelHandler`分成2类，它们作用在不同的地方：

- `ChannelInboundHandler`：当read事件发生时调用
- `ChannelOutboundHandler`：当write事件发生时调用

具体顺序是：`socket.read() -> inboundHandler -> ... -> outboundHandler -> ... ->socket.write()`

# 3. 再探`ChannelPipeline`的初始化

## 3.1. `ChannelPipeline`的实例化

`ChannelPipeline`的实例化在`Channel`实例化时进行，以客户端为例，它的调用链可以是：

- `connect() -> doResolveAndConnect() -> initAndRegister() -> channelFactory#newChannel() -> ... -> ctor in NioSocketChannel`

而`ChannelPipeline`的实例化在`AbstractChannel`的构造方法的`newChannelPipeline()`进行，它会实例化一个`DefaultChannelPipeline`实例

```java
protected DefaultChannelPipeline(Channel channel) {
    this.channel = ObjectUtil.checkNotNull(channel, "channel");
    succeededFuture = new SucceededChannelFuture(channel, null);
    voidPromise =  new VoidChannelPromise(channel, true);
    // 初始化头尾ChannelHandlerContext
    // 而ChannelHandlerContext包装了ChannelHandler
    tail = new TailContext(this);
    head = new HeadContext(this);
    head.next = tail;
    tail.prev = head;
}
```

易知，初始化了头尾2个节点的双向链表，它们都是`ChannelHandlerContext`实例（它包装了`ChannelHandler`），其中：

- 头实现了`ChannelInboundHandler`和`ChannelOutboundHandler`
- 尾仅实现了`ChannelInboundHandler`

而`ChannelHandlerContext`初始化中，有一步很重要，即**标记`mask`**以标识包装的`ChannelHandler`支持哪些操作。

## 3.2. 添加`ChannelHandler`

启动服务端/客户端时，会调用`handler()`方法添加`ChannelHandler`，可往里面添加`ChannelInitializer`实例（它也是`ChannelInboundHandler`实例），以添加多个`ChannelHandler`。

而实际上，真正的添加，是在之前所述的`initAndRegister()`方法中的`init()`方法执行：

```java
// 客户端
void init(Channel channel) throws Exception {
    ChannelPipeline p = channel.pipeline();
    // handler()中指定的Handler,并添加
    p.addLast(config.handler());
    //...
}

// 服务端
void init(Channel channel) throws Exception {
    // ...
    ChannelPipeline p = channel.pipeline();
    // ...
    p.addLast(new ChannelInitializer<Channel>() {
        public void initChannel(final Channel ch) throws Exception {
            final ChannelPipeline pipeline = ch.pipeline();
            // handler()中指定的Handler
            ChannelHandler handler = config.handler();
            if (handler != null) {
                // 添加Handler
                pipeline.addLast(handler);
            }
            ch.eventLoop().execute(new Runnable() {
                public void run() {
                    // 对于服务端，还得添加一个ServerBootstrapAcceptor
                    // 它是ChannelInboundHandler，用于处理新连接
                    // 注意到这里添加了childHandler等信息，
                    // 也说明了，只有连接建立时，childHandler才会被触发
                    pipeline.addLast(new ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                }
    		});
        }
    });
}
```

对于客户端，直接往最后添加`ChannelHandler`（可以是`ChannelInitializer`）；而对于服务端，添加的是一个包装的`ChannelInitializer`。添加在`pipeline.addLast()`执行：

```java
public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) {
    final AbstractChannelHandlerContext newCtx;
    synchronized (this) {
        // 1. 检查重复、重名，创建新的DefaultChannelHandlerContext
        checkMultiplicity(handler);
        newCtx = newContext(group, filterName(name, handler), handler);
        // 2. 添加刚创建的Context
        addLast0(newCtx);
        // ...
    }
    // 3. 触发Handler被添加的事件
    callHandlerAdded0(newCtx);
    return this;
}
```

主要看第2步，可知只是简单的链表添加：

```java
private void addLast0(AbstractChannelHandlerContext newCtx) {
    AbstractChannelHandlerContext prev = tail.prev;
    newCtx.prev = prev;
    newCtx.next = tail;
    prev.next = newCtx;
    tail.prev = newCtx;
}
```

## 3.3. `ChannelInitializer`的`ChannelHandler`添加

由3.2.知，若什么都不处理，Netty只做了延迟处理，链表中的项只是`ChannelInitializer`，而不是我们真正添加的`ChannelHandler`(`ChannelHandlerContext`)，那么我们添加的`ChannelHandler`是如何加入到链表中的？

这里涉及到`EventGroup`的内容，而这部分内容之后会讲，大体的步骤是：

- `Channel`向`EventGroup`注册

- 注册时，需要触发`Channel`注册的事件，那么需要对`pipeline`传播注册消息，这里调用了`Pipeline#fireChannelRegistered()`方法

- 调用该方法，会从`head`传播（传播具体后面描述）到整个链表项

- 到`ChannelInitializer`对应的`Context`时，会触发`handler.channelRegistered()`方法，这时：

  - 它会调用自己的`initChannel()`，将我们添加的`handler`添加到链表中
  - 然后向后传播
  - 最后将自己从链表中移除

  ```java
  public final void channelRegistered(ChannelHandlerContext ctx) throws Exception {
      // 1. 初始化我们定义的channelHandler
      // 这一步会对我们重写的方法进行包装，利用基于ConcurrentHashMap的Set，
      // 利用add是否成功，防止重复初始化
      if (initChannel(ctx)) {
          // 2. 重新传播register事件（从head）
          // 若我们添加的是仍然是ChannelInitializer
          // 那么很明显，会递归添加handler并传播register事件
          ctx.pipeline().fireChannelRegistered();
          // 3. 移除自己到链表外
          removeState(ctx);
       } else {
          // 4. 重复初始化，直接向后传播即可
          ctx.fireChannelRegistered();
      }
  }
  ```

该内容之后也会多次提及。

# 4. `ChannelHandler`的传播

下一篇会说明`ChannelHandler`是怎么传播事件的，这里盗一张图，说明不同的`ChannelHandler`是通过什么方法传播事件的：

![19](https://www.javadoop.com/blogimages/netty-source/19.png)

