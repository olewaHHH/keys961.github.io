---
layout: post
title: "MIT-6.824-Lab #1: MapReduce"
author: "keys961"
comments: true
catalog: true
tags:
  - Distributed System
typora-root-url: ./
---

# 1. 整体架构

Lab #1中的整体架构组织和功能如下：

- Master：
  - 创建`map`和`reduce`任务
  - 提供接口供Worker轮询，派发任务
  - 维护任务状态，如启动、超时、完成等
- Worker：
  - 轮询Master以获取任务
  - 执行任务
  - 将任务结果返回给Master

# 2. 具体执行流程

Lab #1中会执行1个MapReduce任务，完成后流程中止。具体流程如下：

1. Map阶段
   - Master：
     - 传入分片的原始数据文件
     - 创建`map`任务
   - Worker：
     - 轮询以获取`map`任务
     - 执行`map`任务
     - 返回结果给Master
2. Reduce阶段：与1类似，不过需要当所有`map`任务执行完毕后才能进入Reduce阶段

# 3. 任务定义

不论`map`和`reduce`任务，都需要有一个输入，这个输入在本实验中是一个文件名列表，Worker会读取文件列表从而读取输入信息。

具体的定义如下：

```go
type Task struct {
   taskID     int // 任务ID
   taskType   TaskType // 任务类型：map或reduce
   inputFiles []string // 输入文件列表
   status     TaskStatus // 任务状态
   startTime  int64 // 任务起始时间
}

type TaskStatus int8
const (
   Ready     TaskStatus = 0 // 任务就绪
   Executing TaskStatus = 1 // 任务正在执行
   Timeout   TaskStatus = 2 // 任务超时
   Finished  TaskStatus = 3 // 任务执行完毕
)

type TaskType int8
const (
   Map    TaskType = 0 // Map任务
   Reduce TaskType = 1 // Reduce任务
)
```

由于Master需要管理任务超时的情形，所以这里增加了`startTime`字段。之后会提及，Master会轮询所有任务，判断其是否超时，若超时则可以将其派发给其它Worker。

# 4. 任务创建

## 4.1. `map`任务创建

这里的做法很直接：每个输入文件对应一个`map`任务。

然后创建时，将其状态设置为`Ready`。

```go
func (m *Master) generateMapTasks() {
   for id, file := range m.inputFiles {
      task := Task{
         taskID:     id,
         taskType:   Map,
         inputFiles: []string{file},
         status:     Ready,
         startTime:  0,
      }
      m.mapTasks = append(m.mapTasks, &task)
   }
}
```

## 4.2. `reduce`任务创建

启动时，这里会预先创建任务，状态设置为`Ready`。

但是输入文件为空，因为`map`任务根本没有执行。输入文件字段会在`map`任务执行完了后被填充。而`reduce`任务只会在所有`map`任务完成后才能被派发。

```go
func (m *Master) generateReduceTasks() {
   for i := 0; i < m.nReduce; i++ {
      task := Task{
         taskID:     i,
         taskType:   Reduce,
         status:     Ready,
         inputFiles: make([]string, 0), // 这个字段会在map任务执行完后填充
         startTime:  0,
      }
      m.reduceTasks = append(m.reduceTasks, &task)
   }
}
```

## 4.3. `map`和`reduce`任务之间的文件关系

1. 输入文件有`n`个，则`map`任务有`n`个，每个`map`文件读取其中1个文件

2. 每个`map`任务执行完后，会生成`nReduce`个中间文件，平均分摊到每个`reduce`任务上
3. 每个`reduce`任务执行完后，会生成1个最终文件

# 5. 任务轮询

Master创建完任务，Worker启动后，就可以轮询任务了。轮询任务有下面的特性：

1. 优先轮询`map`任务，只有当所有`map`任务完成后才能轮询`reduce`任务

   这个可通过扫描`map`任务状态实现，只有全部的`map`任务状态为`Finished`，才能派发`reduce`任务

2. 只有`Ready`和`Timeout`的任务可以被派发

此外：

1. 为了保证Worker能够正常退出，轮询响应还得捎带一个`Done`字段，当所有的`map`和`reduce`任务完成后，该字段为`true`，Worker就可以退出了
2. 派发任务后，任务的`status`需要转化为`Executing`，并更新`startTime`字段

# 6. 任务结果提交

任务提交后，需要：

- 将对应任务（请求带有任务的`taskID`）的`status`转化为`Finished`，而转化前的状态必须是`Executing`

- 对于`map`任务，需要更新`reduce`任务的`inputFiles`
- 对于`reduce`任务，需要将输出文件的文件名更改为实验要求的`mr-out-<taskID>`

# 7. 超时任务检测

Master会启动一个后台goroutine，检查每个任务的`startTime`。当这个时间戳距离当前时间超过了10秒，就判定其超时，设置状态为`Timeout`。

被设置为`Timeout`的任务可以被再次派发到其他Worker。而假如之前的派发有结果提交，则拒绝（见第6节）。

```go
const Expiration = 10 * 1000 * 1000000 // 10s超时

func (m *Master) checkTaskStatus() {
   m.lock.Lock()
   defer m.lock.Unlock()
   m.checkExpiration() // 检查超时
}

func (m *Master) checkExpiration() {
   current := time.Now().UnixNano()
   for _, task := range m.mapTasks {
      if task.status == Executing {
         if current-task.startTime > Expiration {
            // 超时则设置状态为Timeout
            task.status = Timeout
         }
      }
   }

   for _, task := range m.mapTasks {
      if task.status == Executing {
         if current-task.startTime > Expiration {
            // 超时则设置状态为Timeout
            task.status = Timeout
         }
      }
   }
}
```

# 8. 任务执行

## 8.1. `map`任务

这部分很简单，主要分为下面的内容：

- 创建`nReduce`个中间文件，作为输出
- 读取每个输入文件的内容，传入`mapf`函数，得到一个`kvs`键值对集合
- 遍历每个键值对，将键值对`kv`根据散列值输出到对应的中间文件，具体为`ihash(kv.Key) % nReduce`
- 返回结果

## 8.2. `reduce`任务

这部分和`map`任务类似：

- 创建1个输出文件
  - 必须是临时文件，否则假如出现超时重试时，会出现文件创建失败
  - 当任务完成后，让Master将临时输出文件改名为`mr-out-<taskID>`
- 读取`map`任务产生的每个中间文件，将多个键值对集合（`map[K]V`）合并为一个键值对集合（`map[K][]V`）
- 遍历上一步合并的键值对集合，将键值对`kv`传入`reducef`函数，然后将结果写入输出文件
- 返回结果

## 8.3. 代码示例

```go
func (w *worker) executeMapTask(reply *AcquireTaskReply) error {
	intermediateFiles := make([]*os.File, 0)
	intermediateFileNames := make([]string, 0)
	encoders := make([]*json.Encoder, 0)
	pwd, _ := os.Getwd()
	for i := 0; i < reply.NReduce; i++ {
		filename := fmt.Sprintf("mr-inter-%v-%v-", reply.TaskID, i)
		file, err := ioutil.TempFile(pwd, filename)
		if err != nil {
			log.Fatalf("MAP: Cannot create intermediate file %v", filename)
			return err
		}
		intermediateFiles = append(intermediateFiles, file)
		intermediateFileNames = append(intermediateFileNames, file.Name())
		encoder := json.NewEncoder(file)
		encoders = append(encoders, encoder)
	}

	for _, inputFileName := range reply.InputFiles {
		input, err := os.Open(inputFileName)
		if err != nil {
			log.Fatalf("MAP: Cannot open input file %v", inputFileName)
		}
		content, err := ioutil.ReadAll(input)
		if err != nil {
			log.Fatalf("MAP: Cannot read input file %v", inputFileName)
		}
		_ = input.Close()
		// Execute map function
		kva := w.mapf(inputFileName, string(content))
		for _, kv := range kva {
			reduceId := ihash(kv.Key) % reply.NReduce
			out := encoders[reduceId]
			err = out.Encode(kv)
			if err != nil {
				log.Fatalf("MAP: Cannot write intermediate file %v", inputFileName)
			}
		}
	}

	for _, file := range intermediateFiles {
		_ = file.Close()
	}
	w.callSubmitResult(reply, intermediateFileNames)
	return nil
}

func (w *worker) executeReduceTask(reply *AcquireTaskReply) error {
	intermediateKV := make(map[string][]string)

	pwd, _ := os.Getwd()
	for i := 0; i < reply.NMap; i++ {
		filename := reply.InputFiles[i]
		file, err := os.Open(filename)
		if err != nil {
			log.Fatalf("REDUCE: Cannot open intermediate file %v: %v", filename, err)
			return err
		}
		decoder := json.NewDecoder(file)
		for {
			var kv KeyValue
			if err := decoder.Decode(&kv); err != nil {
				break
			}
			arr, ok := intermediateKV[kv.Key]
			if !ok {
				arr = make([]string, 0)
			}
			arr = append(arr, kv.Value)
			intermediateKV[kv.Key] = arr
		}
		_ = file.Close()
	}

	outputFilename := fmt.Sprintf("mr-reduce-%v-", reply.TaskID)
	output, err := ioutil.TempFile(pwd, outputFilename)
	if err != nil {
		log.Fatalf("REDUCE: Cannot open output file %v", outputFilename)
		return err
	}
	for k, v := range intermediateKV {
		out := w.reducef(k, v)

		_, err := fmt.Fprintf(output, "%v %v\n", k, out)
		if err != nil {
			log.Fatalf("REDUCE: Cannot write output file %v", outputFilename)
		}
	}
	outputName := output.Name()
	_ = output.Close()
	w.callSubmitResult(reply, []string{outputName})
	return nil
}
```

# 9. 总结

上面的文字基本概括了该实验的所有部分实现，总体难度不大，可用于熟悉Go语言的编程。