---
layout: post
title: "MySQL Notes"
author: "keys961"
comments: true
---

# MySQL Notes

## Chapter 1: MySQL 架构

#### 1.1 逻辑架构

最上层是客户端，中间是核心服务功能（查询解析、分析、优化、缓存、内置函数，存储过程、触发器、视图再这里实现），最下层是存储引擎。

- 客户端连接会在服务器进程中拥有一个**线程**，查询只在这个单独的线程中运行。而服务器会缓存线程，不用显式创建/销毁
- MySQL会解析查询并创建解析树，并对其优化（重写查询、更改读取顺序、选合适索引等）。可用hint优化器影响决策，也可以通过`EXPLAIN`查看服务优化的决策
- `SELECT`语句查询前会检查缓存来加速查找

#### 1.2 并发控制

- 锁种类：S锁(Read), X锁(Write)。只有S与S是不互斥的，其它组合都互斥。

- 锁粒度：表锁（粒度大，开销小，并发度低，如`ALTER TABLE`会上表锁），行锁（粒度小，开销大，并发度高，在某些特殊的存储引擎中实现）


#### 1.3 事务

ACID：原子性，一致性（状态一致），隔离性（并发但感觉不到其它事务的存在），持久性。

用`BEGIN`/`START TRANSACTION`开启事务, `COMMIT`提交事务，`ROLLBACK` 回滚事务。

- 隔离级别：MySQL定义了4种

  - `READ UNCOMMIT`：事务的修改，即使没提交，修改也对其它事务可见（即**脏读**）
  - `READ COMMIT`： 事务只能看到已提交事务的修改（解决脏读）。但是一个事务到提交前可能会出现2个相同的查询，不同的结果（即**不可重复读**）
  - `REPEATABLE READ`: 保证同个事务中相同查询结果是一致的（解决不可重复读）。但当别的事务在本事务范围内插入新记录，本事务会感知到这个记录的存在，即**幻读**。InnoDB通过MVCC解决了幻读问题（默认不开启）。（Case: 2个事务A和B，都没提交，A修改了行a，B去读a还是原来的值，因为a加了X锁，B无法加S锁所以去读了**快照**值；若B去修改a会阻塞，因为加不了X锁。若A提交了，B去改，条件可能会失效，条件是不会适配快照的数据）
  - `SERIALIZABLE`：强制事务串行执行，读和写都会对数据（每一行）加锁，解决幻读问题。
- 死锁：InnoDB会检测死锁的循环依赖，抛出错误；以及实现死锁超时机制。死锁错误产生后，InnoDB将持有最好行级X锁的事务回滚。
- 事务日志：采用追加方式，磁盘I/O是顺序的。日志采用Write-Ahead，写入并持久化日志后，数据可以慢慢写回磁盘，即使崩溃了也可以恢复（参考《数据库系统概念》第16章）
- MySQL中的事务
  - 自动提交：`AUTOCOMMIT`默认开启，认为每个语句都是一个事务。而对于不支持事务的引擎（如MyISAM）修改它没任何影响，因为没有事务的概念。
  - 事务控制是由下层的存储引擎实现的，当使用非事务存储引擎，那么它不会回滚/恢复。
  - 2PL：InnoDB使用2PL，只在`COMMIT`或者`ROLLBACK` 后才释放掉所有的锁，且同时释放。
  - 显式锁定：`SELECT ... LOCK IN SHARE MODE/FOR UPDATE`显式加行级IS/IX锁（意向锁）。IS与IX之间是能相容的，但是IS不能与X容，IX不能与S和X相容。`LOCK/UNLOCK TABLES` 对表上锁，在服务层实现，和引擎无关，不能用于替代事务。

#### 1.4 MVCC




