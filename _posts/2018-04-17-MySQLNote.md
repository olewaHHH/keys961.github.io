---
layout: post
title: "MySQL Notes"
author: "keys961"
comments: true
---

# MySQL Notes

## Chapter 1: MySQL 架构

#### 1.1 逻辑架构

最上层是客户端，中间是核心服务功能（查询解析、分析、优化、缓存、内置函数，存储过程、触发器、视图再这里实现），最下层是存储引擎。

- 客户端连接会在服务器进程中拥有一个**线程**，查询只在这个单独的线程中运行。而服务器会缓存线程，不用显式创建/销毁
- MySQL会解析查询并创建解析树，并对其优化（重写查询、更改读取顺序、选合适索引等）。可用hint优化器影响决策，也可以通过`EXPLAIN`查看服务优化的决策
- `SELECT`语句查询前会检查缓存来加速查找

#### 1.2 并发控制

- 锁种类：S锁(Read), X锁(Write)。只有S与S是不互斥的，其它组合都互斥。

- 锁粒度：表锁（粒度大，开销小，并发度低，如`ALTER TABLE`会上表锁），行锁（粒度小，开销大，并发度高，在某些特殊的存储引擎中实现）


#### 1.3 事务

ACID：原子性，一致性（状态一致），隔离性（并发但感觉不到其它事务的存在），持久性。

用`BEGIN`/`START TRANSACTION`开启事务, `COMMIT`提交事务，`ROLLBACK` 回滚事务。

- 隔离级别：MySQL定义了4种

  - `READ UNCOMMIT`：事务的修改，即使没提交，修改也对其它事务可见（即**脏读**）
  - `READ COMMIT`： 事务只能看到已提交事务的修改（解决脏读）。但是一个事务到提交前可能会出现2个相同的查询，不同的结果（即**不可重复读**）
  - `REPEATABLE READ`: 保证同个事务中相同查询结果是一致的（解决不可重复读）。但当别的事务在本事务范围内插入新记录，本事务会感知到这个记录的存在，即**幻读**。InnoDB通过MVCC解决了幻读问题（默认不开启）。（Case: 2个事务A和B，都没提交，A修改了行a，B去读a还是原来的值，因为a加了X锁，B无法加S锁所以去读了**快照**值；若B去修改a会阻塞，因为加不了X锁。若A提交了，B去改，条件可能会失效，条件是不会适配快照的数据）
  - `SERIALIZABLE`：强制事务串行执行，读和写都会对数据（每一行）加锁，解决幻读问题。
- 死锁：InnoDB会检测死锁的循环依赖，抛出错误；以及实现死锁超时机制。死锁错误产生后，InnoDB将持有最好行级X锁的事务回滚。
- 事务日志：采用追加方式，磁盘I/O是顺序的。日志采用Write-Ahead，写入并持久化日志后，数据可以慢慢写回磁盘，即使崩溃了也可以恢复（参考《数据库系统概念》第16章）
- MySQL中的事务
  - 自动提交：`AUTOCOMMIT`默认开启，认为每个语句都是一个事务。而对于不支持事务的引擎（如MyISAM）修改它没任何影响，因为没有事务的概念。
  - 事务控制是由下层的存储引擎实现的，当使用非事务存储引擎，那么它不会回滚/恢复。
  - 2PL：InnoDB使用2PL，只在`COMMIT`或者`ROLLBACK` 后才释放掉所有的锁，且同时释放。
  - 显式锁定：`SELECT ... LOCK IN SHARE MODE/FOR UPDATE`显式加行级IS/IX锁（意向锁）。IS与IX之间是能相容的，但是IS不能与X容，IX不能与S和X相容。`LOCK/UNLOCK TABLES` 对表上锁，在服务层实现，和引擎无关，不能用于替代事务。

#### 1.4 MVCC

MVCC是行级锁的一个变种，但很多情况下避免加锁操作，典型有乐观实现和悲观实现。

InnoDB实现：通过保存数据在某个时间点的快照。每行记录维护2个列——行创建时间T1，行过期/删除时间T2。此外每个事务都有一个自己的时间T（没开始一个新事务，T会递增）。

只支持RR和RC。

RR下：

- `SELECT`: 满足下面2个条件即作为结果

  - 只找T1 <= T的数据行
  - T2要么没定义，要么T2 > T

- `INSERT`: 插入新的一行，该行的T1 = T

- `DELETE`: 删除一行，该行的T2 = T

- `UPDATE`: 会插入一行新记录，其T1 = T；同时把原来行的T2 = T


大多数读不用加锁，读性能好。但是要额外的存储空间，做更多的行检查工作，以及额外的维护。

#### 1.5 MySQL存储引擎 

> 可用`SHOW TABLE STATUS`显示表的相关信息

- InnoDB（默认）

  用来处理大量短期事务，且很少回滚。

  - 数据存储在表空间（一系列数据文件组成），每个表数据和索引放在单独文件中
  - 使用MVCC支持高并发，实现4个隔离标准，默认为RR
  - 使用间隙锁防止幻读（锁定查询的行且对索引间隙进行锁定，防止幻行插入）
  - 表基于聚簇索引建立（查询性能高），其辅助索引必须包含主键列，所以主键应尽可能小，否则索引会非常大
  - 存储格式平台独立
  - 内部优化：可预测读、自适应hash索引、插入缓冲区等等
  - 是事务型存储引擎，支持热备份（系统处于正常运转状态下的备份，不需要停止写入）

- MyISAM

  引擎设计简单，数据以紧密格式存储，某些场景下性能很好。

  不支持事务特性，不支持行锁，是以前的默认存储引擎。

  - 表存储在2个文件：数据文件(`.myd`)，索引文件(`.myi`)
  - 加锁与并发：只支持表锁，读上S锁，写上X锁。不过查询同时可以插入新记录，即并发插入
  - 可手动修复，但不支持事务级别的恢复
  - 支持全文索引（InnoDB不支持），且可延迟更新索引键（`DELAY_KEY_WRITE`选项，极大提高写入性能，但是崩溃后索引会损坏，需要修复）
  - 可对表压缩，适合导入数据后不再修改的场景，其索引是只读的

- Memory

  数据保存在内存中，性能更好，但是重启后数据会丢失（结构不会丢失）

  - 只支持表锁
  - 支持Hash索引
  - 适用于查找/映射表，缓存周期性聚合数据，保存中间数据

#### 1.6 选用合适的引擎

从这些因素考虑：**事务**，**备份** ，**崩溃恢复**，**特有特性**

#### 1.7 转换存储引擎

- `ALTER TABLE table_name ENGINE = engine_name;`

- `mysqldump` 导出，并修改`CREATE TABLE` 引擎选项，然后导入

- `CREATE`&`SELECT`,综合使用前2种方法



## Chapter 2：MySQL Benchmark

#### 2.1 策略

分为：集成式、单组件式

- 测试指标
  - ​
- ​



